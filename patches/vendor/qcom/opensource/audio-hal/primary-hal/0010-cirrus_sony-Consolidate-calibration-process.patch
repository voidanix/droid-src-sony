From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AngeloGioacchino Del Regno <angelogioacchino.delregno@somainline.org>
Date: Sat, 13 Feb 2021 18:45:05 +0100
Subject: [PATCH] cirrus_sony: Consolidate calibration process

On devices with multiple CS35L41 amps the calibration process is a bit
slower for.. reasons.
First of all, the DSP likes to just take time to get back alive after
the calibration run succeeding (reasons unknown: firmware is closed)
and there is no way to know when it precisely comes back to life.

Then, this task being now very much time consuming brings more issues
to the table, like the audio HAL trying to playback sounds from the
OS before the calibration run is done: this may actually interact with
the calibration silence and/or confuse the DSP and make it crash, which
is why we now need to carefully set and check the module state, meaning
that we are obliged to check and forbid audio playback if this software
is waiting for DSP calibration.

The result of this is that *at least* Sony Edo, featuring this kind of
dual-amp cofiguration, can now calibrate and switch to protection FW
without requiring a system reboot, even though it's going to be a bit
slow: this was ignored for the sake of safety and audio quality through
the internal speakers and it is very important to recalibrate this
when we have the opportunity to, as the TA-stored calibration cannot be
accounting for hardware aging while, with this, WE CAN.
---
 hal/audio_extn/cirrus_sony.c | 102 +++++++++++++++++++++++++++--------
 1 file changed, 79 insertions(+), 23 deletions(-)

diff --git a/hal/audio_extn/cirrus_sony.c b/hal/audio_extn/cirrus_sony.c
index 3f6595c18d1a50646ddaeefc701aaf4ca5e5165d..979024df3fe09d59ecd34ad24c9c69298fbedfd0 100644
--- a/hal/audio_extn/cirrus_sony.c
+++ b/hal/audio_extn/cirrus_sony.c
@@ -141,8 +141,8 @@ int (*miscta_write_unit)(uint32_t id, const void *buf, uint32_t size) = NULL;
 #define CIRRUS_CTL_NAME_BUF 40
 #define CIRRUS_ERROR_DETECT_SLEEP_US	250000
 
-#define CIRRUS_FIRMWARE_LOAD_SLEEP_US	2500
-#define CIRRUS_FIRMWARE_MAX_RETRY	10
+#define CIRRUS_FIRMWARE_LOAD_SLEEP_US	5000
+#define CIRRUS_FIRMWARE_MAX_RETRY	30
 
 /* Saved calibrations */
 #ifndef CIRRUS_AUDIO_CAL_PATH
@@ -529,7 +529,7 @@ static int cirrus_set_mixer_array_by_name(char* ctl_name,
 
     ctl_config = mixer_get_ctl_by_name(card_mixer, ctl_name);
     if (!ctl_config) {
-        ALOGE("%s: Cannot get mixer control %s", __func__, ctl_name);
+        ALOGD("%s: Cannot get mixer control %s", __func__, ctl_name);
         ret = -1;
         goto exit;
     }
@@ -699,6 +699,7 @@ exit:
 
     fp_disable_audio_route(adev, uc_info_rx);
     fp_disable_snd_device(adev, uc_info_rx->out_snd_device);
+
     list_remove(&uc_info_rx->list);
     free(uc_info_rx);
 
@@ -755,6 +756,24 @@ static int cirrus_do_reset(const char *channel) {
     return ret;
 }
 
+static int cirrus_mixer_wait_for_setting(char *ctl, int val, int retry)
+{
+    int i, ret;
+
+    for (i = 0; i < retry; i++) {
+        /* Start firmware download sequence: shut down DSP and reset states */
+        ret = cirrus_get_mixer_value_by_name(ctl);
+        if (ret < 0 || ret == val)
+            break;
+
+        usleep(10000);
+    }
+    if (ret < 0 && i == retry)
+        return -ETIMEDOUT;
+
+    return ret;
+}
+
 static int cirrus_exec_fw_download(const char *fw_type, const char *channel,
                                    int do_reset) {
     char *ctl_name;
@@ -787,6 +806,13 @@ static int cirrus_exec_fw_download(const char *fw_type, const char *channel,
         ALOGE("%s: Cannot reset %s status", __func__, ctl_name);
         goto exit;
     }
+
+    ret = cirrus_mixer_wait_for_setting(ctl_name, 0, 10);
+    if (ret < 0) {
+        ALOGE("%s: %s wait setting error %d", __func__, ctl_name, ret);
+        goto exit;
+    }
+
     usleep(10000);
 
     ret = cirrus_format_mixer_name("DSP1 Preload Switch",
@@ -798,6 +824,13 @@ static int cirrus_exec_fw_download(const char *fw_type, const char *channel,
         ALOGE("%s: Cannot reset %s", __func__, ctl_name);
         goto exit;
     }
+
+    ret = cirrus_mixer_wait_for_setting(ctl_name, 0, 10);
+    if (ret < 0) {
+        ALOGE("%s: %s wait setting error %d", __func__, ctl_name, ret);
+        goto exit;
+    }
+
     usleep(10000);
 
     /* Determine what firmware to load and configure DSP */
@@ -852,13 +885,18 @@ retry_fw:
 
     ret = cirrus_get_mixer_array_by_name(ctl_name, &cspl_ena, 4);
     if (ret < 0) {
-        ALOGE("%s: Cannot get %s stats", __func__, ctl_name);
-        goto exit;
+        if (retry < CIRRUS_FIRMWARE_MAX_RETRY) {
+            retry++;
+            ALOGI("%s: Retrying...\n", __func__);
+            goto retry_fw;
+        } else {
+            ALOGE("%s: Cannot get %s stats", __func__, ctl_name);
+            goto exit;
+        }
     }
 
     if ((cspl_ena[0] + cspl_ena[1] + cspl_ena[2]) == 0 && cspl_ena[3] == 1) {
         ALOGI("%s: Cirrus %s Firmware Download SUCCESS.", __func__, fw_type);
-
         /* Wait for the hardware to stabilize */
         usleep(100000);
         ret = 0;
@@ -1348,18 +1386,32 @@ exit:
     return ret;
 }
 
+static int cirrus_do_fw_calibration_download(struct cirrus_playback_session *hdl)
+{
+    int ret = 0;
+
+    ret = cirrus_exec_fw_download("Calibration", 0, 0);
+    if (ret < 0) {
+        ret = cirrus_exec_fw_download("Calibration", "L", 0);
+        ret += cirrus_exec_fw_download("Calibration", "R", 0);
+        if (ret != 0)
+            return ret;
+
+        /* Dual amp case */
+        hdl->is_stereo = true;
+    }
+
+    return ret;
+}
+
 static void *cirrus_do_calibration() {
     struct audio_device *adev = handle.adev_handle;
     int ret = 0, dev_file = -1;
-    int prev_state = handle.state;
 
     pthread_mutex_lock(&adev->lock);
     handle.state = CALIBRATING;
     pthread_mutex_unlock(&adev->lock);
 
-    if (prev_state == INIT)
-        prev_state = IDLE;
-
     if (handle.spkl.cal_ok && handle.spkr.cal_ok)
         goto skip_calibration;
 
@@ -1367,18 +1419,12 @@ static void *cirrus_do_calibration() {
            __func__, cal_ambient[0], cal_ambient[1], cal_ambient[2],
            cal_ambient[3]);
 
-    ret = cirrus_exec_fw_download("Calibration", 0, 0);
-    if (ret < 0) {
-        ret = cirrus_exec_fw_download("Calibration", "L", 0);
-        ret += cirrus_exec_fw_download("Calibration", "R", 0);
-        if (ret != 0) {
-            ALOGE("%s: Cannot send Calibration firmware: bailing out.",
-                  __func__);
-            ret = -EINVAL;
-            goto end;
-        }
-        /* Dual amp case */
-        handle.is_stereo = true;
+    ret = cirrus_do_fw_calibration_download(&handle);
+    if (ret != 0) {
+        ALOGE("%s: Cannot send Calibration firmware: bailing out.",
+              __func__);
+        ret = -EINVAL;
+        goto end;
     }
 
     if (handle.is_stereo)
@@ -1390,7 +1436,8 @@ static void *cirrus_do_calibration() {
         ALOGE("%s: CRITICAL: Calibration failure", __func__);
         goto end;
     }
-    ALOGI("%s: Calibration success", __func__);
+    ALOGI("%s: Calibration success! Saving state and waiting for DSP...",
+          __func__);
 
     ret = cirrus_save_calibration(&handle);
     if (ret) {
@@ -1399,6 +1446,15 @@ static void *cirrus_do_calibration() {
         ret = 0;
     }
 
+    /*
+     * There is no way to know when the DSP will be really ready. Usually,
+     * it takes around 4 seconds, but let's wait a bit more... In any case
+     * the calibration process happens only *once* in an entire userdata
+     * life, which means that only the first boot ever will be slow, in
+     * favor of a good speaker calibration.
+     */
+    sleep(6);
+
 skip_calibration:
     if (handle.is_stereo)
         ret = cirrus_do_fw_stereo_download(0);
